# Руководство: Красивое логирование в Oat++

Вы хотите сделать логи читаемыми и стильными (как в NestJS или Spring), используя стандартные макросы `OATPP_LOGD`, `OATPP_LOGI`, `OATPP_LOGE`. Oat++ позволяет полностью переопределить то, как выводятся логи.

## 1. Теория: Архитектура логирования Oat++

В Oat++ логирование построено на интерфейсе `oatpp::base::Logger`.
Когда вы вызываете макрос, например `OATPP_LOGI("Tag", "Message")`, происходит следующее:
1.  Макрос проверяет текущий **уровень приоритета** (включен ли INFO?).
2.  Если включен, вызывается метод `log()` установленного в системе логгера.

По умолчанию используется `DefaultLogger`, который просто пишет в `std::cout`/`std::cerr`. Чтобы получить "красоту", нужно заменить его на свой.

### Интерфейс Logger
Вам нужно создать класс, наследующий `oatpp::base::Logger`, и реализовать всего один метод:

```cpp
void log(v_uint32 priority, const std::string& tag, const std::string& message) override;
```

*   `priority`: Уровень важности (DEBUG, INFO, WARNING, ERROR).
*   `tag`: Категория лога (обычно имя класса или модуля, например "Gateway").
*   `message`: Само сообщение.

---

## 2. Инструментарий: ANSI Colors

Чтобы раскрасить текст в консоли Linux/macOS (и современных Windows), используются специальные **ANSI escape-коды**. Это невидимые символы, которые говорят терминалу "начни писать красным" или "сделай жирным".

**Базовые коды:**
*   `\033[0m`  — Сброс (вернуть обычный цвет)
*   `\033[31m` — Красный (Red) → для ошибок
*   `\033[32m` — Зеленый (Green) → для Nest-style тегов
*   `\033[33m` — Желтый (Yellow) → для предупреждений
*   `\033[34m` — Синий (Blue) → для информационных сообщений
*   `\033[1m`  — **Жирный** (Bold)

**Пример использования:**
```cpp
std::cout << "\033[32m[Success]\033[0m Operation complete" << std::endl;
```
Выведет `[Success]` зеленым, а остальное — обычным цветом.

---

## 3. План реализации (Blueprint)

Вот шаги, которые вы должны выполнить самостоятельно:

### Шаг 1: Создайте класс `PrettyLogger`
Создайте файл `src/logger/PrettyLogger.hpp`.

Внутри класса определите константы для цветов.
Реализуйте метод `log`:
1.  **Форматирование времени**: Используйте `std::chrono` или `std::time`, чтобы получить строку вида `26.11.2025, 13:10:59`.
2.  **Выбор цвета по приоритету**:
    *   Если `priority == PRIORITY_V` (Verbose) или `PRIORITY_D` (Debug) — серый или синий.
    *   Если `PRIORITY_I` (Info) — зеленый или белый.
    *   Если `PRIORITY_E` (Error) — красный.
3.  **Сборка строки**: Сформируйте итоговую строку.
    *   Пример формата: `[Цвет][Тэг][Сброс] - [Время] [ЦветСообщения]Сообщение[Сброс]`

### Шаг 2: Регистрация логгера
В `main.cpp`, **перед** вызовом `oatpp::Environment::init()`, вы должны подменить стандартный логгер.

```cpp
// В начале main()
auto logger = std::make_shared<PrettyLogger>(); // Ваш класс
oatpp::base::Environment::setLogger(logger);

oatpp::Environment::init();
// ... 
```

### Шаг 3: Использование
В коде (в контроллерах, сервисах) используйте стандартные макросы. Тег указывайте первым аргументом.

```cpp
// В GatewayService
OATPP_LOGI("Gateway", "Service started on port %s", HTTP_PORT);

// В Controller
OATPP_LOGD("Api", "Request received for %s", endpoint_name);
```

## 4. Советы по дизайну (NestJS Style)

Чтобы добиться стиля как на скриншоте:
1.  Левая часть (Тэг приложения/PID) может быть фиксированной ширины.
2.  Тэг модуля (например `[NestFactory]`, `[Gateway]`) делайте ярко-желтым или зеленым.
3.  Само сообщение оставляйте белым, но ключевые данные (порты, URL) можно подсвечивать (если передавать их как параметры форматирования, но это сложнее).

Удачи с реализацией! Это отличная практика работы с потоками вывода и переопределения системных компонентов Oat++.

---

## 5. Реализация (Post-Factum)

Мы успешно реализовали кастомный логгер. Ниже приведено описание итогового решения и исправленных ошибок.

### 5.1. Структура файлов
*   `src/internal/logger/ansi_colors.h`: Содержит `#define` для ANSI-кодов (RED, GREEN, RESET и т.д.).
*   `src/internal/logger/PrettyLogger.h`: Класс логгера.

### 5.2. Класс PrettyLogger (Исправленный)
Важные моменты реализации:
1.  **Наследование**: Класс должен наследоваться от `oatpp::Logger`, а не от `oatpp::base::Log` (как предполагалось изначально).
2.  **Зависимости**: Добавлены `<iostream>`, `<iomanip>` (для `std::put_time`), `<chrono>`.
3.  **Приоритеты**: Используются константы `PRIORITY_V` и т.д., доступные напрямую из базового класса `oatpp::Logger`.

```cpp
class PrettyLogger : public oatpp::Logger { // ✅ Правильное наследование
   public:
    void log(v_uint32 priority, const std::string& tag, const std::string& message) override {
        // ... получение времени ...
        switch (priority) {
            case PRIORITY_I: // ✅ Прямой доступ к константам
                std::cout << RESET << GREEN << ... << std::endl;
                break;
            // ...
        }
    }
};
```

### 5.3. Инициализация (Main.cpp)
Первоначальная попытка использовать `oatpp::Environment::setLogger(logger)` до `init()` иногда приводила к тому, что стандартный логгер перехватывал управление.

**Правильный способ:** передать логгер прямо в функцию инициализации.

```cpp
int main() {
    auto logger = std::make_shared<PrettyLogger>();
    oatpp::Environment::init(logger);  // ✅ Гарантированная установка логгера
    
    run();
    
    oatpp::Environment::destroy();
    return 0;
}
```

### 5.4. Использование макросов
Макросы Oat++ **регистрозависимы**.
*   `OATPP_LOGI` — ❌ Ошибка (в старых версиях или других неймспейсах).
*   `OATPP_LOGi` — ✅ Правильно (в `oatpp/base/Log.hpp`).

**Пример вызова:**
```cpp
OATPP_LOGi("Gateway", "Service started on port "  HTTP_PORT);
```
Обратите внимание, что форматирование в Oat++ логгере работает как поток (stream), а не как printf
